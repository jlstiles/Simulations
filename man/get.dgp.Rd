% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/chooseGen.R
\name{get.dgp}
\alias{get.dgp}
\title{get.dgp}
\usage{
get.dgp(n, d, pos = 0.01, minATE = -2, minBV = 0, depth, maxterms,
  minterms, mininters, num.binaries = floor(d/4), force.confounding = TRUE,
  skewing = c(-1, 1))
}
\arguments{
\item{n, }{sample size}

\item{d, }{dimension of potential confounders}

\item{pos, }{a small value to make sure prop scores are in (pos, 1 - pos)}

\item{minATE, }{minimum causal risk difference for the population.}

\item{minBV, }{minimum blip variance for population}

\item{depth, }{specify depth of interaction--must be less than or equal d.}

\item{maxterms, }{maximum terms per interaction.  For example, this would limit 
two way interactions to maximally 10 terms as well as three way or main terms.
With high dimension it is wise to set this low because it might take a while
otherwise.  Still in development--perhaps future will set this for each depth}

\item{minterms}{sets a minimum number of total covariate terms, including 
interactions with eachother--do not set lower than 1.}

\item{mininters}{sets the minimum number of interactions with treatment to include
This must be bigger or equal to minterms}

\item{num.binaries}{specifies number of main terms you want as binaries, must be 
less than d.}

\item{force.confounding}{forces variables used for p-score to overlap with those
used for outcome regression.}

\item{skewing}{randomly skews an otherwise centered dgp for generating binary treatment
default is c(-1, 1).  Set to c(-5,-1) to deliberately skew more regularly or widen to 
c(-3, 3) to skew more randomly.}
}
\value{
a sample DF, the true average treatment effect, ATE0 and blip variance
BV0, the sample pscores, PGn, the sample true blips, blip_n, the sample 
true prob of death under treatment, PQ1n, and prob of death under control
PQ0n
}
\description{
randomly creates a dgp and attempts to satisfy user specs. Number of covariates
is not limited but may take a while beyond d = 20 with too many terms. Limit time with depth
and maxterms parameters.
}
\examples{
# getting a random sample from a randomly drawn dgp.  We specify 3 covariates, a minimum population ATE of .1
# a minimum variance of blip of .03, up to 2 way interactions, limit positivity violations to less than 1\% of the
# population having propensity scores below .05 or above .95, 1 binary, up to 1 interaction terms and at least 1
# term included as a covariate in outcome regression and in treatment mechanism
dgp = get.dgp(n = 1000, d = 3, pos = 0.05, minATE = .1, minBV = .03, depth = 2, maxterms = 3, minterms = 1, 
              mininters = 1, num.binaries = 1) 

# population blip variance (VTE)
dgp$BV0
# population average treatment effect
dgp$ATE0
# sample proportion with treatment
mean(dgp$DF$A)
# sample proportion who died
mean(dgp$DF$Y)
# min sample pscore
min(dgp$PGn)
# max sample pscore
max(dgp$PGn)
# sample dataframe
head(dgp$DF)
# histogram of blips
hist(dgp$blip_n)
# histogram of propensity scores
hist(dgp$PGn)


###
# The following example is for pt treatment.  
###
# using built-in package functions, g0_linear and define Q0_linear to specify
# pscore and outcome model probabilities
data(longdata)
head(data_pt)
g0_linear
Q0_linear = function(A,W1,W2,W3,W4) plogis(A + W1 + W2 + A*(W3 + W4) + W3 +W4)

# get the truth setting A to 1
setA = 1
truth = mean(with(gendata(1e6, g0_linear, Q0_linear), Q0_linear(A=setA,W1,W2,W3,W4)))
truth

# well-specified model
n=1000

formulas = list(formula("Y ~ A + W1 + W2 + A*(W3 + W4) + W3 +W4"))
Ynodes = c("Y")
Anodes = c("A")
setA = 1
formulas_g = list(formula("A ~ W1 + W2 + W3 + W4"))

TSMinfo = long.TSM(data = data_pt, Ynodes = Ynodes, Anodes = Anodes, 
                   formulas = formulas, formulas_g = formulas_g, tmle = TRUE, setA = setA, alpha = .05)

TSMinfo1 = long.TSM(data = data_pt, Ynodes = Ynodes, Anodes = Anodes, 
                    formulas = formulas, formulas_g = formulas_g, tmle = FALSE, setA = setA, alpha = .05)
# get CI
TSMinfo$CI
TSMinfo1$CI
# get influence curve
TSMinfo$IC

# TMLE recovers truth from misspecified outcome model by getting pscore right
# non-tmle does not

# misspecified outcome regression
formulas = list(formula("Y ~ A"))
Ynodes = c("Y")
Anodes = c("A")
setA = 1
# correctly specified g
formulas_g = list(formula("A ~ W1 + W2 + W3 + W4"))

TSMinfo = long.TSM(data = data_pt, Ynodes = Ynodes, Anodes = Anodes, 
                   formulas = formulas, formulas_g = formulas_g, tmle = TRUE, setA = setA, alpha = .05)

# non-tmle
TSMinfo1 = long.TSM(data = data_pt, Ynodes = Ynodes, Anodes = Anodes, 
                    formulas = formulas, formulas_g = formulas_g, tmle = FALSE, setA = setA, alpha = .05)
# get CI
TSMinfo$CI
TSMinfo1$CI

####
# example with longitudinal intervention
####
# enter data with time-ordering correct
head(data_long)
Ynodes = c("Y_1", "Y_2","Y_3","Y_4")
Anodes = c("A1_0", "A1_1","A1_2","A1_3")

# specify the formulas
formula0 = formula("Y_1 ~ L2_0 + L1_0 + A1_0") 
formula1 = formula("Y_2 ~ L2_1 + A1_1")
formula2 = formula("Y_3 ~ L2_2 + A1_2")
formulas = list(formula0, formula1, formula2)
formula_g0 = formula("A1_0 ~ L2_0 + L1_0") 
formula_g1 = formula("A1_1 ~ L2_1 + A1_0")
formula_g2 = formula("A1_2 ~ L2_2 + A1_1")
formulas_g = list(formula_g0, formula_g1, formula_g2)
setA = c(0,1,1)

# tmle (takes about 6 seconds on a mac with 4 cores)
time = proc.time()
TSMinfo = long.TSM(data = data_long, Ynodes = Ynodes, Anodes = Anodes, 
                   formulas = formulas, formulas_g = formulas_g, tmle = TRUE, setA = setA, alpha = .05,
                   parallel = TRUE)
proc.time() - time
# non-tmle
TSMinfo1 = long.TSM(data = data_long, Ynodes = Ynodes, Anodes = Anodes, 
                    formulas = formulas, formulas_g = formulas_g, tmle = FALSE, setA = setA, alpha = .05)
# get CI
TSMinfo$CI

# ignoring propensity score gives much smaller variance but gives small variance
# and high bias if confounding is present
TSMinfo1$CI

}
